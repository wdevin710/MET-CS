cat("Square of ", i, " = ", i*i, "\n")
}
my.max <- function (x) {
result <- -Inf
for (number in x) {
if (number > result) {
result <- number
}
}
return (result)
}
my.max(c(100, 50, 200, 80))
max(c(100, 50, 200, 80))
x <- 1:10
x
x[10:1]
x <- 20:29
x
x[10:1]
my.reverse <- function (x) {
return (x[length(x):1])
}
my.reverse(c(10, 50, 100))
my.reverse(20:30)
my.reverse <- function (x) {
x[length(x):1]
}
my.reverse(c(10, 50, 100))
my.reverse(20:30)
my.factorial <- function (n) {
if (n <= 0) {
return (1)
} else {
return (n * my.factorial(n-1))
}
}
my.factorial(5)
factorial(5)
n <- 10
1:10
sum(1:n)
x <- c(10, 13, 19, 9, 1)
diff(x)
c(0, diff(x))
x[2: length(x)]
x[1: (length(x) - 1)]
x[2: length(x)] - x[1: (length(x) - 1)]
#Excercise a:
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
#Excercise a:
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
#i) How may items in the vector
length(scores)
#ii) Access first two items
scores[1:2]
#iii) Access first and last items
scores[c(1, length(scores))]
#iv) Access middle two items
scores[c(length(scores)/2, (length(scores)/2)+1)]
#Excercise b:
m <- median(scores)
m
#i) scores less than or equal to median
scores <= m
#ii) scores greater than median
scores > m
scores[scores > m]
#iii) sum of scores less than or equal to median
sum(scores <= m)
#iv) sum of scores greater than median
sum(scores > m)
#Excercise c:
#Median
m
#i) Scores less that or equal to median
scores[scores <= m]
#ii) scores greater than median
scores[scores > m]
#i) Odd indexed values from scores using logical indexing
scores[c(TRUE, FALSE)]
#i) Even indexed values from scores using logical indexing
scores[c(FALSE, TRUE)]
#i) Odd indexed values from scores using logical indexing
scores[seq(from=1, to=length(scores), by=2)]
#i) Even indexed values from scores using logical indexing
scores[seq(from=2, to=length(scores), by=2)]
paste(LETTERS[1:length(scores)], scores, sep="=")
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow = TRUE)
scores.matrix
#first and last column of the matrix
scores.matrix[, c(1, ncol(scores.matrix))]
#Assign row names and column names
row_names <- paste("Quiz", seq(1:nrow(scores.matrix)), sep = "_")
col_names <- paste("Student", seq(1:ncol(scores.matrix)), sep = "_")
dimnames(scores.matrix) <- list(row_names, col_names)
scores.matrix
#single expression
dimnames(scores.matrix) <- list(paste("Quiz", seq(1:nrow(scores.matrix)), sep = "_"), paste("Student", seq(1:ncol(scores.matrix)), sep = "_"))
dow.month <- c("Jan","Feb","Mar","Apr","May")
dow.open <- c(28639, 28320, 25591, 21227, 24121)
dow.high <- c(29374, 29569, 27102, 24765, 24350)
dow.low <- c(28170, 24681, 18214, 20735, 23361)
dow.close <- c(28256, 25409, 21917, 24346, 24331)
dow.info <- data.frame(
Month = dow.month,
Open = dow.open,
High = dow.high,
Low = dow.low,
Close = dow.close)
dow.info
#summary of last four columns
summary(dow.info[-1])
#Slice data frame using columns
dow.info[c("Month","Open","Close")]
#Slice data frame using rows
dow.info[c(1,nrow(dow.info)),]
dow.info[c(1,nrow(dow.info)),c("Month","High","Low")]
#Logical indexing
dow.info[dow.info$Low > 25000 & dow.info$Open > 25000, ]
#Subset
subset(dow.info, Low > 25000 & Open > 25000)
# add a new column Volatility
dow.info$Volatility <- dow.info$High - dow.info$Low
dow.info
subset(dow.info, Volatility == max(Volatility))
dow.info[dow.info$Volatility == min(dow.info$Volatility),]
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
#a
length(scores)
scores[1:2]
scores[c(1,length(scores))]
scores[c(length(scores)/2,length(scores)/2 +1)]
#b
median(scores)
scores <= median(scores)
scores > median(scores)
sum(scores <= median(scores))
sum(scores > median(scores))
#c
scores[scores <= median(scores)]
scores[scores > median(scores)]
#d
scores[c(TRUE, FALSE)]
scores[c(FALSE, TRUE)]
#e
scores[seq(from =1, to =length(scores), by =2)]
scores[seq(from =2, to =length(scores), by =2)]
#f
paste(LETTERS[1:length(scores)], scores, sep = "=")
#g
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow = TRUE)
scores.matrix
#h
scores.matrix[,c(1,ncol(scores.matrix))]
#i
dimnames(scores.matrix) <- list(
c(paste("Quiz", 1:nrow(scores.matrix), sep = "_")),
c(paste("Student", 1:ncol(scores.matrix), sep = "_")))
scores.matrix
#j
scores.matrix[,c(1,ncol(scores.matrix))]
#a
dow <- data.frame(
c("Jan", "Feb", "Mar", "Apr", "May"),
c(28639, 28320, 25591, 21227, 24121),
c(29374, 29569, 27102, 24765, 24350),
c(28170, 24681, 18214, 20735, 23361),
c(28256, 25409, 21917, 24346, 24331))
colnames(dow) <- c("Month","Open","High","Low","Close")
dim(dow)
dow
#b
summary(dow[-1])
#c
dow[c("Month", "Open", "Close")]
#d
dow[c(1,nrow(dow)), ]
#e
dow[c(1,nrow(dow)), c("Month", "High", "Low")]
#f
dow[dow$Low > 22000, ]
subset(dow, Low > 22000)
#g
dow[dow$Low > 25000 & dow$Open > 25000, ]
subset(dow, Low > 25000 & Open > 25000)
#h
dow$Volatility <- dow$High - dow$Low
dow
#i
subset(dow, Volatility == max(Volatility))
#j
dow[dow$Volatility == min(dow$Volatility), ]
# how many students took the exam?
scores = c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
# how many students took the exam?
length(scores)
# access the first two elements
scores[1:2]
# access the first and last element
scores[c(1,length(scores))]
# access the middle two element (even number of items in vector)
scores[c(length(scores)/2,(length(scores)/2) + 1)]
# b
median(scores)
# show scores <= median
scores <= median(scores)
# show scores > median(scores)
scores > median(scores)
# sum qty of scores <= median(scores)
sum(scores <= median(scores))
# sum qty of scores > median(scores)
sum(scores > median(scores))
# display the median scores values <= median
scores[scores <= median(scores)]
# display the median scores values > median
scores[scores > median(scores)]
# Display the odd indexed items in scores (Use True/false indexing)
scores[c(TRUE, FALSE)]
# Display the even indexed items in scores
scores[c(F, T)]
# Display the odd indexed items in scores (Use numeric indexing)
scores[seq(1, length(scores), by=2)]
# Display the even indexed items in scores
scores[seq(2, length(scores), by=2)]
# Use paste to display "A=59" "B=46", etc.
paste(LETTERS[1:length(scores)], scores, sep = "=")
# Create 2x5 matrix of data
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow=T)
# Show the first and last columns of the matrix
scores.matrix[c(1,nrow(scores.matrix)), c(1,ncol(scores.matrix))]
# Assign row and column names to the scores.matrix
dimnames(scores.matrix) <- list(paste("Quiz", 1:nrow(scores.matrix), sep="_"),
paste("Student", 1:ncol(scores.matrix), sep="_"))
scores.matrix
# Show the results for displaying the first and last elements of the matrix
scores.matrix[c(1,nrow(scores.matrix)), c(1,ncol(scores.matrix))]
# Create and display the data frame
dow <- data.frame(
Month = c("Jan", "Feb", "Mar", "Apr", "May"),
Open  = c(28639, 28320, 25591, 21227, 24121),
High  = c(29374, 29569, 27102, 24765, 24350),
Low   = c(28170, 24681, 18214, 20735, 23361),
Close = c(28256, 25409, 21917, 24346, 24331))
dow
# show the result of the summary function for Open, High, Low and Close
summary(dow[2:5])
dow[c("Month", "Open", "Close")]
# Show data frame sliced for first and last rows
dow[c(1,length(dow)),]
length(dow)
length(dow[1,])
dow[1,]
length(dow[1,c(2,3)])
dow[c(1,2)]
length(dow[c(1,2)])
?length
#1a)
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
length (scores)
scores[1:2]
scores[c(1,length(scores))]
scores[c(length(scores)/2, (length(scores)/2)+1)]
#1b)
median (scores)
scores <= median(scores)
scores >= median(scores)
sum(median(scores)<=scores)
sum(median(scores)>=scores)
#1c)
scores[c(median(scores)>=scores)]
scores[c(median(scores)<=scores)]
#1d)
scores[c(TRUE, FALSE)]
scores[c(FALSE,TRUE)]
#1e)
scores[c(seq(1,length(scores),by=2))]
scores[c(seq(2,length(scores),by=2))]
#1f)
paste(LETTERS [1:length(scores)], scores, sep=" = ")
#1g)
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow = TRUE)
scores.matrix
#1h)
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow = TRUE)
scores.matrix[ , c(1,ncol(scores.matrix))]
#1i)
scores.matrix <- matrix(scores, nrow = 2, ncol = 5, byrow = TRUE)
dimnames(scores.matrix) <- list(
c("Quiz_1", "Quiz_2"), c(paste("Student", 1:ncol(scores.matrix), sep="_")))
scores.matrix
#1j)
scores.matrix[ , c(1,ncol(scores.matrix))]
#2a)
Month <- c("Jan", "Feb", "Mar", "Apr", "May")
Open <- c(28639, 28320, 25591, 21227, 24121)
High <- c(29374, 29569, 27102, 24765, 24350)
Low <- c(8170, 24681, 18214, 20735, 23361)
Close <- c(28256, 25409, 21917, 24346, 24331)
dow <- data.frame(Month, Open, High, Low, Close)
dow
#2b)
summary(dow[c(2:5)])
#2c)
dow[c(1:3)]
#2d)
dow[c(1, c(length(dow))),  ]
#2e)
dow[c(1, c(length(dow))), c("Month", "High", "Low")]
#2f)
dow[(Low>22000), ]
subset(dow, Low >22000)
dow[Low > 22000, ]
#2g)
dow[c(Open > 25000) & (Low>25000), ]
subset(dow, Open > 25000 & Low >25000)
#2h)
dow$Volatility <- dow$High - dow$Low
dow
#2i)
subset(dow, Volatility == max(Volatility))
#2j)
subset(dow, Volatility == min(Volatility))
#Part 1
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
#Part 1.a
#number.student
length(scores)
#first 2 items
scores[c(1,2)]
#first and laSt items
scores[c(1, length(scores))]
#the middle two items
scores[c(length(scores)/2, length(scores)/2 +1)]
#Part 1.b
#Median
median(scores)
#compare if scores is less than or equal median
scores <= median(scores)
#compare if scores is greater than median
scores > median(scores)
#the number of the scores less than or equal the median
sum(scores <= median(scores))
#the number of the scores greater than median
sum(scores > median(scores))
#Part 1.c
#The scores are less than or equal the median
scores[scores <= median(scores)]
#The scores are greater than or equal the median
scores[scores >= median(scores)]
#Part 1.d
#The scores for the odd indexed values by logical index
scores[c(TRUE, FALSE)]
#The scores for the even indexed values by logical index
scores[c(FALSE, TRUE)]
#Part 1.e
#The scores for the odd indexed values by numeric index
scores[seq(1,length(scores),2)]
#The scores for the even indexed values by numeric index
scores[seq(2,length(scores),2)]
#Part 1.f
paste(LETTERS[c(1:length(scores))],scores, sep = "=")
#Part 1.g
score.matrix <- matrix(scores,2,length(scores)/2, byrow = TRUE)
score.matrix
#Part 1.h
score.matrix[,c(1,ncol(score.matrix))]
#Part 1.i
dimnames(score.matrix) <- list(c(paste('Quiz', seq(1,nrow(score.matrix)), sep = '_')),
c(paste('Student',seq(1,ncol(score.matrix)), sep = '_')))
score.matrix
#Part 1.j
score.matrix[,c(1,ncol(score.matrix))]
#Part 2
open <- c(28639, 28320, 25591, 21227, 24121)
high <- c(29374, 29569, 27102, 24765, 24350)
low <- c(28170, 24681, 18214, 20735, 23361)
close <- c(28256, 25409, 21917, 24346, 24331)
month <- c('Jan', 'Feb', 'Mar', 'Apr', 'May')
#Part 2.a
dow = data.frame('Month'=month, 'Open'=open, 'High'=high, 'Low'=low, 'Close'=close)
dow
#Part 2.b
summary(dow[c('Open','High','Low','Close')])
#Part 2.c
dow[c('Month','Open','Close')]
#Part 2.d
dow[c(1,nrow(dow)),]
#Part 2.e
dow[c(1,nrow(dow)), c('Month', 'High', 'Low')]
#Part 2.f
#By logical indexing
dow[c(dow['Low']>22000),]
#By subset
subset(dow, Low>22000)
#Part 2.g
#By logical indexing
dow[c(dow['Low']>25000 & dow['Open']>25000),]
#By subset
subset(dow, Low>25000 & Open>25000)
#Part 2.h
dow$Volatility <- dow$High - dow$Low
dow
#Part 2.i
subset(dow, dow$Volatility == max(dow$Volatility))
#Part 2.j
dow[dow$Volatility == min(dow$Volatility),]
scores <- c(59, 46, 76, 60, 49, 65, 82, 68, 99, 52)
scores
#Part One
#number of students who took the exam
print(length(scores))
#first two items
print(scores[1:2])
#first and last element
print(scores[c(1, length(scores))])
#the middle two elements
print(scores[c(length(scores)/2, (length(scores)/2 + 1))])
#median score
print(median(scores))
#scores less than or equal to the median
print(scores <= median(scores))
#scores greater than the median
print(scores > median(scores))
#number of scores less than or equal to the median
print(sum(scores <= median(scores)))
#number of scores greater than the median
print(sum(scores > median(scores)))
#scores that are less than or equal to the median
print(scores[scores <= median(scores)])
#scores that are greater than the median
print(scores[scores > median(scores)])
#scores at odd index using logical indexing
scores[c(TRUE, FALSE)]
#scores at even index using logical indexing
scores[c(FALSE, TRUE)]
#scores at odd index using numeric indexing
scores[seq(length(scores)) %% 2 == 1]
#scores at even index using numeric indexing
scores[seq(length(scores)) %% 2 == 0]
#paste function with Letters
paste(LETTERS[1:length(scores)], '=',scores)
# 2X5 matrix for scores data
scores.matrix = matrix(scores, nrow=2, ncol=5, byrow = TRUE)
print(scores.matrix)
#first and last columns of the matrix
print(scores.matrix[, c(1, ncol(scores.matrix))])
#assign names to rows and columns
dimnames(scores.matrix) <- list(paste('quiz', seq(1:nrow(scores.matrix)), sep='_'), paste('student', seq(1:ncol(scores.matrix)), sep='_'))
#first and last columns of the matrix
print(scores.matrix[, c(1, ncol(scores.matrix))])
#create a dataframe
Month <- c('Jan', 'Feb', 'Mar', 'Apr', 'May')
Open <- c(28639, 28320, 25591, 21227, 24121)
High <- c(29374, 29569, 27102, 24765, 24350)
Low <- c(28170, 24681, 18214, 20735, 23361)
Close <- c(28256, 25409, 21917, 24346, 24331)
dow <- data.frame(Month, Open, High, Low, Close)
print(dow)
#get the summary of the data frame
summary(dow)
#get the sliced data for the columns Month, Open, and Close
dow[c('Month', 'Open', 'Close')]
#get the first and last row
dow[c(1,nrow(dow)), ]
#get the first and last row for columns Month, High, and Low
dow[c(1,nrow(dow)), c('Month', 'High', 'Low')]
#get all rows whose low is greater than 22,000 using logical indexing
dow[dow$Low > 22000, ]
#get all rows whose low is greater than 22,000 using subset
subset(dow, Low > 22000)
#get all rows whose open and low is greater than 25,000 using logical indexing
dow[(dow$Open > 25000 & dow$Low > 25000), ]
#get all rows whose open and low is greater than 25,000 using subset
subset(dow, Open > 22000 & Low > 25000)
#add new column Volatility and show the difference between high and low
dow$Volatility <- dow$High - dow$Low
print(dow)
#get the maximum volatility using subset and max function
subset(dow, Volatility==max(dow$Volatility))
#get the minimum volatility using logical indexing and min function
dow[dow$Volatility == min(dow$Volatility), ]
library(prob)
# 3 red balls and 2 blue balls
L<- rep(c("red", "blue"), times=c(3,2))
# make sample sapce M
M<- urnsamples(L, size=2, replace=FALSE, ordered= TRUE)
# make probability space S
S<- probspace(M)
S
# the probability of both balls being red is 0.3
Prob(S, X1=="red"&X2=="red")
# the probability of 1st ball being red and 2nd ball being blue is 0.3
Prob(S, X1=="red"&X2=="blue")
L<- rep(c("red", "blue"), times=c(3,2))
M1<- urnsamples(L, size=2, replace=FALSE, ordered= FALSE)
S1<- probspace(M1)
# the probability of both balls being red is 0.3
Prob(S1, X1=="red"&X2=="red")
# the probability of 1st ball being red and 2nd ball being blue is 0.6
Prob(S1, X1=="red"&X2=="blue")
S1
S
L = c('r1','r2','r3','b1',b2)
L = c('r1','r2','r3','b1','b2')
M1<- urnsamples(L, size=2, replace=FALSE, ordered= FALSE)
S1<- probspace(M1)
S1
# make sample sapce M
M<- urnsamples(L, size=2, replace=FALSE, ordered= TRUE)
# make probability space S
S<- probspace(M)
S
