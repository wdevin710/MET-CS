{
    "collab_server" : "",
    "contents" : "# Script to be run on the FCX Cloud Platform \n#  Please insert your code in \"Forecast.Electric.Demand()\"\n\nlibrary(\"RSNNS\")\nlibrary(\"jsonlite\")\n\n### Pre-Process Data & Call Neural Network \nParse.JSON.Input <- function (inputs) \n{\n  ix <- grep(\"Relative_Humidity\",inputs$historian$TagName); InputData <-data.frame(inputs$historian$Samples[[ix]]$TimeStamp,stringsAsFactors = FALSE); \n  InputData <-cbind(InputData, as.numeric(inputs$historian$Samples[[ix]]$Value),stringsAsFactors = FALSE)\n  ix <- grep(\"Outdoor_Dewpoint\",inputs$historian$TagName); InputData <- cbind(InputData, as.numeric(inputs$historian$Samples[[ix]]$Value),stringsAsFactors = FALSE)\n  ix <- grep(\"Outdoor_Temperature\",inputs$historian$TagName); InputData <- cbind(InputData, as.numeric(inputs$historian$Samples[[ix]]$Value),stringsAsFactors = FALSE)\n  ix <- grep(\"BUE_Stud_Electric_Demand_kW\",inputs$historian$TagName); InputData <- cbind(InputData, as.numeric(inputs$historian$Samples[[ix]]$Value),stringsAsFactors = FALSE)\n  ix <- grep(\"Optimal_Electric_Demand_kW\",inputs$historian$TagName); InputData <- cbind(InputData, as.numeric(inputs$historian$Samples[[ix]]$Value),stringsAsFactors = FALSE)\n  ix <- grep(\"Outputs.Predicted_Electric_Demand\",inputs$parameters$Name); InputData <- cbind(InputData, inputs$parameters$Tag[[ix]],stringsAsFactors = FALSE)\n  colnames(InputData) <- c(\"DATE\",\"Relative_Humidity\",\"Outdoor_Dewpoint\",\"Outdoor_Temperature\",\"Electric_Demand_kW\",\"Optimal_Electric_Demand_kW\",\"TagName\")\n  return (InputData) # Returned object\n}\n\nForecast.Electric.Demand <- function (Raw_Data) \n{\n  library(\"RSNNS\")\n  print(\"2. Inputs sent to function: Forecast.Electric.Demand()\")\n  # Convert Time Stemps\n  Num.Data.Points <- dim(Raw_Data)[1]\n  Time.Stamp <- strptime(Raw_Data$DATE,\"%Y-%m-%dT%H:%M:%S\")\n  \n  # Select Training Range \n  StartTime <- 1 # which(Time.Stamp==\"2014-03-01 01:00:00 EST\")\n  TrainRange <- StartTime:Num.Data.Points\n  print(paste0(\"Training data start date: \",Time.Stamp[StartTime]))\n  \n  # Extract Hours field from Time.Stamp\n  Hours <- rep(1,length(TrainRange)) # Replace this Line\n  # Insert your code here\n  \n  # Extract Days field from Time.Stamp\n  Day.Number <- rep(1,length(TrainRange)) # Replace this Line\n  # Insert your code here\n  \n  # Modify Hours & Days\n  Hours.Modified <- Hours # Replace this Line\n  Day.Number.Modified <- Day.Number # Replace this Line\n  # Insert your code here\n  print(\"Extracting Hour_of_Day & Day_of_Week fields from the DATE field Time Stamp \")\n  \n  # Choose Data to Process \n  Dependent.Ix <- c(2:4) # Select dependent columns\n  Dependent.Data <- cbind(Hours.Modified, Day.Number.Modified, Raw_Data[TrainRange,Dependent.Ix]); # X ()\n  Independent.Ix <- c(5) # Select Independent columns\n  Independent.Data <- Raw_Data[TrainRange,Independent.Ix]; # Y (Actual Electric Demand )\n  print(\"Dependent data tags: \");  print(names(Dependent.Data))\n  print(\"Independent data tags: \");  print(names(Raw_Data[Independent.Ix]))\n  \n  # Define NuNet Inputs\n  inputs <- Dependent.Data # Actual Consumption - used for training\n  targets <- Independent.Data # Expected Consumption (Regression data) used as Tags\n  Percent.To.Test <- 0.30 # Split the input data into train and test\n  print(\"Define NuNet Inputs: \"); print(paste0(\"Percent of input data to test: \", 100*Percent.To.Test, \" %\"))\n  \n  # Train NuNet & Get Predictions\n  print(\"Train NuNet & Get Predictions, please wait... \");\n  Predicted.Electric.Demand <- TrainNuNet(inputs,targets,Percent.To.Test) \n  # Predicted.Electric.Demand <- list(rep(0,Num.Data.Points)) # Populate with zero\n  print(\"NuNet Training finished!\");\n  \n  # Actual.Electric.Demand <- Independent.Data \n  # Output <- list(Predicted.Electric.Demand)\n  Output <- data.frame(\"TimeStamp\"=Time.Stamp,\"Value\"=unlist(Predicted.Electric.Demand),\"Quality\"=3)\n  \n  return (Output) # Returned object\n  \n}\n\n\nTrainNuNet <- function (inputs,targets,Percent.To.Test) \n{\n  # Normalize the Data \n  if (is.null(dim(inputs))) # Single Column Input\n  {\n    z <- max(inputs, na.rm=TRUE) # find Max in Single Input Column\n    inputs.scale <- z; targets.scale <- max(targets)\n    inputs.normalized <- inputs/inputs.scale # Normalize Data\n    targets.normalized <- targets/targets.scale # Normalize Data \n  }\n  else # Multi Colum Input\n  {\n    z <- apply(inputs, MARGIN = 2, function(x) max(x, na.rm=TRUE)) # find Max in Each Input Column\n    inputs.scale <- as.vector(z); targets.scale <- max(targets);\n    inputs.normalized <- sweep(inputs, 2, inputs.scale, `/`) # Normalize Data\n    targets.normalized <- targets/targets.scale # Normalize Data   \n  }\n  \n  \n  # Split the Data into Train and Test\n  patterns <- splitForTrainingAndTest(inputs.normalized, targets.normalized, ratio = Percent.To.Test) \n  set.seed(13);\n  \n  # Train NN to folow Actual \n  # The use of an Elman network (Elman 1990) for time series regression.\n  model <- elman(patterns$inputsTrain, patterns$targetsTrain,\n                 size = c(10, 10), learnFuncParams = c(0.1), maxit = 1300,\n                 inputsTest = patterns$inputsTest, targetsTest = patterns$targetsTest,\n                 linOut = FALSE)\n  # model <- elman(patterns$inputsTrain, patterns$targetsTrain,\n  #                size = c(8, 8), learnFuncParams = c(0.1), maxit = 500,\n  #                inputsTest = patterns$inputsTest, targetsTest = patterns$targetsTest,\n  #                linOut = FALSE)\n  \n  NN.fitted.Train <- model$fitted.values*targets.scale \n  NN.fitted.Test <- model$fittedTestValues*targets.scale \n  \n  Predicted.Electric.Demand <- c(NN.fitted.Train,NN.fitted.Test)\n  \n  result <- list(Predicted.Electric.Demand)\n  \n  return (result) # Returned object\n}\n\nwrapper <- function(inputJSON.Data){\n  # # Import data \n  \n  inputs <- fromJSON(inputJSON.Data, flatten=TRUE)\n  InputData <- Parse.JSON.Input(inputs) # Turn JSON Input to DataFrame\n  print(\"1. Historian Database input tags imported to R Script:\")\n  print(names(InputData))\n  Output <- Forecast.Electric.Demand(InputData) \n  temp <- as.character( Output$TimeStamp); Output$TimeStamp <- paste0(sub(\" \",\"T\",temp),\"Z\")\n  \n  # In Historian Format \n  z <- list(\"TagName\"=InputData$TagName[1],ErrorCode=0,\"DataType\"=\"DoubleFloat\" ,\"Samples\"=Output)\n  \n  Predicted.Electric.Demand <- toJSON(list(z),pretty=TRUE)\n  print(\"3. Predicted Electric Demand from NuNet saved to Historian Database\")\n  \n  return(Predicted.Electric.Demand)\n}\n",
    "created" : 1533230162352.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1750510029",
    "id" : "ECBE9DDE",
    "lastKnownWriteTime" : 1533229837,
    "last_content_update" : 1533229837,
    "path" : "~/My Files/Teachng/2018/Summer/Classroom/Class 9/IoT Code/IIoT Lab/FCX_Cloud_Script.R",
    "project_path" : "FCX_Cloud_Script.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}